#summary Examples of video capture using v4l4j.
#labels Featured
#sidebar v4l4jSideBar

This page shows a few examples in Java on how to use v4l4j. It assumes you have successfully compiled and installed v4l4j (see GettingStarted page for detailed instructions). Here, video source refers to any video-capture device supported by the Linux kernel, and accessible through the Video4Linux API using the associated device file (usually /dev/video0). The v4l4j API has many more methods and classes than presented here. Be sure to check the Java documentation for a more complete reference.
Below, you will find the following examples:
 * *Initialising the video device*: Creating a java object to interact with a video device.
 * *Gathering information about the device*: finding out the number of inputs, tuners, supported image formats, supported capture resolutions and lots more.
 * *Dealing with controls*: List the controls associated with a video device and get / set their values.
 * *Capturing frames*: Getting a `FrameGrabber` object to capture images from the video device.
 * *Display video in a GUI (JFrame)*: Create a graphical interface (JFrame) to display the captured video stream.
Suggestions for more examples are welcome.

= Initialising the video device =
All interactions with a video device are done using a `VideoDevice` object. To instantiate one, you simply needs its device file:
{{{
String dev = "/dev/video0";
VideoDevice vd = new VideoDevice(dev);
}}}
The VideoDevice object allows you to:
  * get textual information about the video device itself, such as its name, the supported image formats & resolutions, and the type of video inputs,
  * capture frames through a `FrameGrabber` object (or one of its subclasses),
  * control tuners the device may have, through the `TunerList` object,
  * access video control, such as brightness, contrast, and gain, through the `ControlList` object.

*Once the `VideoDevice` is no longer needed, you must release resources and free data structures by calling the `release()` method:*
{{{
vd.release();
}}}

= Gathering information about the device =
The `DeviceInfo` class contains lots of information about a video device. To get the `DeviceInfo` object, use:
{{{
DeviceInfo di = vd.getDeviceInfo();
}}}

`DeviceInfo` objects contain:
    * the device file,
    * the name of the video device,
    * a list of `InputInfo` object providing information about each video input,
    * an `ImageFormatList` object providing information about the supported image formats.

Each `InputInfo` object contains:
    * The textual name of the input,
    * The supported standards (`V4L4JConstants.STANDARD_PAL`, `V4L4JConstants.STANDARD_SECAM`, `V4L4JConstants.STANDARD_NTSC` or `V4L4JConstants.STANDARD_WEBCAM`)
    * The input type (`V4L4JConstants.INPUT_TYPE_TUNER` or `V4L4JConstants.INPUT_TYPE_CAMERA`)
    * The `TunerInfo` object associated with this input if it is connected to a tuner.

`TunerInfo` objects contain:
    * the tuner type: `V4L4JConstants.TUNER_TYPE_RADIO` or `V4L4JConstants.TUNER_TYPE_TV`,
    * the frequency unit: `V4L4JConstants.FREQ_KHZ` or `V4L4JConstants.FREQ_MHZ`,
    * the name of the tuner,
    * the index of the tuner,
    * and the lowest and highest tunable frequencies.

Lastly, the `ImageFormatList` object details the native image formats & resolutions supported by the video device. This object also lists native image formats that can be encoded into more convenient formats: JPEG, RGB24, BGR24, YUV420 and YVU420.
{{{
//get the ImageFormatList object
ImageFormatList l = vd.getDeviceInfo().getFormatList();


//List all supported image formats & resolutions
for(ImageFormat f : l.getList()) {
  System.out.println("\t"+f.getName()+" - "+f.getIndex());
  System.out.println("\t\tResolutions: "+f.getResolutionInfo());
}


//List all supported image formats that can be JPEG-encoded
System.out.println("Some formats can be JPEG-encoded? "+(vd.supportJPEGConversion()?"Yes":"No"));
if(vd.supportJPEGConversion()){
  System.out.println("List of Formats that can be JPEG-encoded:");
  for(ImageFormat f: d.getFormatList().getJPEGEncodableFormats())
    System.out.println("\t"+f.getName()+" - "+f.getIndex());
}


//List all supported image formats that can be RGB24-converted
System.out.println("Some formats can be RGB-converted? "+(vd.supportRGBConversion()?"Yes":"No"));
if(vd.supportRGBConversion()){
  System.out.println("List of Formats that can be converted to RGB:");
  for(ImageFormat f: d.getFormatList().getRGBEncodableFormats())
    System.out.println("\t"+f.getName()+" - "+f.getIndex());
}
}}}



= Capturing frames =
A `FrameGrabber` object (or one of its subclasses) gives you access to the frame capture facility. There are 6 types of frame grabbers: raw, JPEG, RGB, BGR, YUV and YVU. Raw frame grabbers will capture a frame and hand it in straight away in its native format. All other frame grabbers will capture a frame and convert its format before handing it in. Most video devices can have their image converted. v4l4j has a few conversion routines of its own, and relies on libv4l to preform camera-specific processing. You can check whether a video device supports JPEG/RGB/YUV -encoding by calling:
{{{
VideoDevice vd = new VideoDevice("/dev/video0");
if(!vd.supportJPEGConversion()){ // use the other supportXXXConversion() for other formats
  vd.release();
  throw new Exception("The video device does not support JPEG encoding");
}
}}}
Frame grabber constructors need at least 4 arguments:
 * the desired capture resolution in pixels - width and height. Setting them to `V4L4JConstants.MAX_WIDTH` and `V4L4JConstants.MAX_HEIGHT` will request the highest supported resolution.
 * the input channel, this depends on the hardware, webcams have only 1 input (0), capture cards can have many,
 * the video standard (`FrameGrabber.STANDARD_WEBCAM`, `FrameGrabber.STANDARD_PAL`, `FrameGrabber.STANDARD_SECAM`, `FrameGrabber.STANDARD_NTSC`)

{{{
FrameGrabber fg;
int width = 640, height = 480, input = 0, standard = V4L4JConstants.STANDARD_PAL;
fg = vd.getRawFrameGrabber(width, height, input, channel);

//find out what image format is used
ImageFormat imf = fg.getImageFormat()

...

vd.releaseFrameGrabber();
}}}
The above code will create a frame grabber object capturing frames in the first image format supported by the device, as returned by:
{{{
vd.getDeviceInfo().getFormatList().getNativeFormats().get(0);
}}}
Alternatively, you can use specify the desired image format: 
{{{
ImageFormat imf = null;
for(ImageFormat i: vd.getDeviceInfo().getFormats().getList())
  if(i.getName().equals(IMF_YUYV)
    imf = i;
if(img==null)
  throw new Exception(IMF_YUYV +" format not supported");

fg = vd.getRawFrameGrabber(width, height, input, channel, imf);
}}}


A JPEG frame grabber is instantiated by calling:
{{{
FrameGrabber fg;
int width = 640, height = 480, input = 1, standard = V4L4JConstants.STANDARD_PAL, quality = 80;
fg = vd.getJPEGFrameGrabber(width, height, input, channel, quality);

...

vd.releaseFrameGrabber();
}}}
The `quality` argument is the JPEG compression parameter (between 0 and 100 inclusive), the lower the value, the lower the picture quality. The previous code creates a jpeg `FrameGrabber` object. The requested capture resolution is 640x480, from input 1 using PAL video standard and a JPEG compression factor of 80. As with raw frame grabbers, you can also specify the capture image format (ie the format images should be captured in before being JPEG-encoded) with:
{{{
ImageFormat imf = vd.getDeviceInfo().getFormatList().getJPEGEncodableFormats().get(0);
fg = vd.getJPEGFrameGrabber(width, height, input, channel, quality, imf);

...

vd.releaseFrameGrabber();
}}}

An RGB frame grabber is instantiated by calling:
{{{
FrameGrabber fg;
int width = 640, height = 480, input = 1, standard = V4L4JConstants.STANDARD_NTSC;
fg = vd.getRGBFrameGrabber(width, height, input, channel);

...

vd.releaseFrameGrabber();
}}}
Here again,  you can also specify the capture image format (ie the format images should be captured in before being converted to RGB24) with:
{{{
ImageFormat imf = vd.getDeviceInfo().getFormatList().getRGBEncodableFormats().get(0);
fg = vd.getRGBFrameGrabber(width, height, input, channel, quality, imf);

...

vd.releaseFrameGrabber();
}}}



Regardless of the kind of frame grabber, the requested capture resolution given in the constructor is simply an indication and can be adjusted by V4L to the closest resolution supported by the video device. The actual width and height that will be used can be retrieved using:
{{{
int actualWidth = f.getwidth();
int actualHeight = f.getHeight();
}}}

When the `FrameGrabber` is no longer used, resources must be released by calling
{{{
vd.releaseFrameGrabber();
}}}

= Dealing with controls =
Once the `VideoDevice` is intialised, a call to `getControlList()` will return a `ControlList` object. This object encapsulates (among other things) a `List<Control>` accessible through the `getList()` method. The following code loops over all controls and prints their name, range of acceptable values, and current value.
{{{
List<Control> controls = vd.getControlsList().getList();
for(Control c: controls)
 System.out.println("control name: "+c.getName()+" - min: "+c.getMin()+" - max: "+c.getMax()+" - step: "+c.getStep()+" - value: "+c.getValue());
vd.releaseControlList();
}}}
Resetting the Pan angle on a Logitech Quickcam Sphere can be done using:
{{{
vd.getControlList().getControl("Pan Reset").setValue(1);
}}}
*Once again, when the `ControlList` is no longer needed, it MUST be released by calling `releaseControlList()` on the `VideoDevice`.*

= Display video in a GUI (JFrame) =
Assuming the `FrameGrabber` object `f` has been successfully initialised, to start capturing frames, do the following:
{{{
VideoFrame frame;
int stop=0;
f.startCapture();
while(!stop) {
 frame = f.getVideoFrame();
 //do something useful with frame
 //the captured frame size is returned by calling frame.getFrameLength()
 //a byte array with the image data is obtained with frame.getBytes()
 //When no longer needed, you must recycle the frame
 frame.recycle();
}
f.stopCapture()
//dont forget to call f.release() when done with f
}
}}}

The following example shows you how to capture JPEG-encoded frames from your video device and display them in a JFrame object through using a BufferedImage object.
{{{
package v4l4jTest;

import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import java.nio.ByteBuffer;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import au.edu.jcu.v4l4j.FrameGrabber;
import au.edu.jcu.v4l4j.exceptions.V4L4JException;
import au.edu.jcu.v4l4j.VideoDevice;
import au.edu.jcu.v4l4j.V4L4JConstants;

public class Viewer extends WindowAdapter implements Runnable {
	private VideoDevice vd;
	private JLabel l;
	private JFrame f;
	private long start = 0;
	private int n;
	private FrameGrabber fg;
	private Thread captureThread;
	private boolean stop;
        private int width, height;
	
	/**
	 * Builds a WebcamViewer object
	 * @param dev the video device file to capture from
	 * @param w the desired capture width
	 * @param h the desired capture height
	 * @param std the capture standard
	 * @param channel the capture channel
	 * @param qty the JPEG compression quality
	 * @throws V4L4JException if any parameter if invalid
	 */
    public Viewer(String dev, int w, int h, int std, int channel, int qty) throws V4L4JException{
        initFrameGrabber(dev, w, h, std, channel, qty);
        initGUI();
        stop = false;
        captureThread = new Thread(this, "Capture Thread");
        captureThread.start();
    }
    
    /** 
     * Creates the graphical interface components and initialises them
     */
    private void initGUI(){
        f = new JFrame();
        l = new JLabel();
        f.getContentPane().add(l);
        f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        f.addWindowListener(this);
        f.setVisible(true);
        f.setSize(width, height);    	
    }
    
    /**
     * Initialises the FrameGrabber object with the given parameters
	 * @param dev the video device file to capture from
	 * @param w the desired capture width
	 * @param h the desired capture height
	 * @param std the capture standard
	 * @param channel the capture channel
	 * @param qty the JPEG compression quality
	 * @throws V4L4JException if any parameter if invalid
     */
    private void initFrameGrabber(String dev, int w, int h, int std, int channel, int qty) throws V4L4JException{
	vd = new VideoDevice(dev);
	fg = vd.getJPEGFrameGrabber(w, h, channel, std, qty);
	fg.startCapture();
        width = fg.getWidth();
        height = fg.getHeight();
	System.out.println("Starting capture at "+fg.getWidth()+"x"+fg.getHeight());	    	
    }
    
    /**
     * Updates the image shown in the JLabel
     * @param b
     */
    public void setImage(BufferedImage image) {
    	l.getGraphics().drawImage(image, 0, 0, width, height, null);
    }
    
    /**
     * Implements the capture thread: get a frame from the FrameGrabber, and display it
     */
    public void run(){
	VideoFrame frame;
	try {			
		while(!stop){
			frame = fd.getVideoFrame();
			setImage(frame.getBufferedImage());
                        frame.recycle();
		}
	} catch (V4L4JException e) {
		e.printStackTrace();
		System.out.println("Failed to capture image");
	}
    }

    /**
     * Catch window closing event so we can free up resources before exiting
     * @param e
     */
	public void windowClosing(WindowEvent e) {
		if(captureThread.isAlive()){
    			stop = true;
    			try {
				captureThread.join();
			} catch (InterruptedException e1) {}
    		}
		
		fg.stopCapture();
		vd.releaseFrameGrabber();
		
    		f.dispose();		
	}
	
	

	public static void main(String[] args) throws V4L4JException, IOException {

		String dev = "/dev/video0";
		int w=640, h=480, std=V4L4JConstants.STANDARD_WEBCAM, channel = 0, qty = 60;
		new Viewer(dev,w,h,std,channel,qty);
	}
}

}}}